# 2-4 Design and implement conversation parser

[Back to task list](./tasks.md)

Design and implement a parser to extract messages, identify user vs agent responses, and extract metadata from Cursor's SQLite database. This parser will query the `state.vscdb` database file and convert Cursor's internal format into structured data that can be used for markdown export and session tracking.

**Database Path**: `{cursor.log_path}/globalStorage/state.vscdb` where `cursor.log_path` is the configured Cursor User directory (e.g., `~/.config/Cursor/User/`).

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-11-14 22:41:32 | Created | N/A | Proposed | Task file created | System |
| 2025-01-27 00:00:00 | Status Change | Proposed | Agreed | Task approved | User |
| 2025-01-27 00:00:00 | Status Change | Agreed | InProgress | Started implementation | AI Agent |
| 2025-01-27 00:00:00 | Status Change | InProgress | Review | Implementation complete, all tests passing | AI Agent |
| 2025-01-27 00:00:00 | Status Change | Review | Done | Task completed and verified | User |

## Requirements

1. Open SQLite database: `{cursor.log_path}/globalStorage/state.vscdb`
2. Query for conversation data using composer IDs
3. Extract individual messages from database (bubbleId entries)
4. Identify user messages (type=1) vs agent responses (type=2)
5. Extract metadata: timestamps, composer IDs, conversation status
6. Handle database locking gracefully (use read-only mode)
7. Support incremental parsing (for conversation updates)
8. Return structured data suitable for markdown export
9. Handle edge cases (database locked, missing entries, etc.)
10. Get cursor log path from config: `config.Cursor.LogPath`

## Implementation Plan

1. Design parser interface:
   - Location: `internal/cursor/parser.go`
   - Package: `cursor`
2. Define data structures:
   ```go
   type Conversation struct {
       SessionID    string
       Project      string
       StartTime    time.Time
       EndTime      time.Time
       Messages     []Message
   }
   
   type Message struct {
       Timestamp   time.Time
       Role        string // "user" or "agent"
       Content     string
       Metadata    map[string]interface{}
   }
   ```
3. Implement SQLite database access:
   - Use `database/sql` with SQLite driver (`github.com/mattn/go-sqlite3` or `modernc.org/sqlite`)
   - Open database in read-only mode: `?mode=ro` to avoid locking issues
   - Get database path: `filepath.Join(cfg.Cursor.LogPath, "globalStorage", "state.vscdb")`
   - Query `cursorDiskKV` table for conversation data
4. Implement database queries:
   - Query composer data: `SELECT value FROM cursorDiskKV WHERE key = 'composerData:{composerId}'`
   - Query message bubbles: `SELECT value FROM cursorDiskKV WHERE key = 'bubbleId:{composerId}:{bubbleId}'`
   - Parse JSON-encoded BLOB values
   - Extract `fullConversationHeadersOnly` array from composer data
5. Implement message extraction:
   - Iterate through `fullConversationHeadersOnly` to get message order
   - Query each bubbleId to get message content
   - Convert to internal Message structs
6. Implement role identification:
   - Use `type` field from bubble data: 1 = user, 2 = agent
7. Extract metadata:
   - Parse timestamps from `createdAt` fields (Unix milliseconds or ISO 8601)
   - Extract composer ID as conversation identifier
   - Extract conversation status from composer data
7. Handle errors:
   - Return parsing errors for malformed files
   - Log warnings for missing optional fields
   - Continue parsing if possible despite errors
8. Support incremental parsing:
   - Track what has been parsed before
   - Only parse new/updated sections
9. Write comprehensive unit tests:
   - Test with sample log files
   - Test error cases
   - Test edge cases

## Test Plan

**Objective**: Verify conversation parser correctly extracts messages and metadata from Cursor log files.

**Test Scope**:
- Log file parsing
- Message extraction
- Role identification
- Metadata extraction
- Error handling

**Environment & Setup**:
- Use sample SQLite database from research (task 2-1)
- Create test fixtures with known database structure
- Test with read-only database access

**Key Test Scenarios**:
1. Open database file successfully
2. Query composer data correctly
3. Query message bubbles correctly
4. Extract all messages correctly
5. Identify user messages (type=1) correctly
6. Identify agent responses (type=2) correctly
7. Extract timestamps correctly
8. Extract composer ID correctly
9. Handle database locking gracefully (read-only mode)
10. Handle missing entries gracefully
11. Handle corrupted database gracefully
12. Support incremental parsing for updates

**Success Criteria**:
- All messages extracted correctly
- User vs agent identification accurate
- Metadata extracted correctly
- Error handling works for malformed files
- Parser handles edge cases gracefully

## Verification

- [x] Parser interface designed
- [x] Data structures defined
- [x] Log file parsing implemented
- [x] Message extraction implemented
- [x] Role identification implemented
- [x] Metadata extraction implemented
- [x] Error handling implemented
- [x] Incremental parsing supported
- [x] Unit tests written and passing
- [x] Parser handles edge cases

## Files Modified

- `internal/cursor/parser.go` (new) - Conversation parser implementation
- `internal/cursor/types.go` (new) - Data structures for conversations and messages
- `internal/cursor/parser_test.go` (new) - Unit tests for parser
- `docs/api-specs/cursor/cursor-api.md` (updated) - API specification

