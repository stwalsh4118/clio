# 2-8 Handle conversation updates and modifications

[Back to task list](./tasks.md)

## Description

Handle updates to existing conversations that are modified after initial capture. Cursor may update conversation logs as users continue chatting, and we need to detect these updates and update the database records accordingly.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-11-14 22:41:32 | Created | N/A | Proposed | Task file created | System |
| 2025-11-15 03:40:00 | Status Change | Proposed | InProgress | Started implementation | AI Agent |
| 2025-11-15 03:40:00 | Status Change | InProgress | Review | Implementation complete, all tests passing | AI Agent |
| 2025-11-15 03:40:00 | Status Change | Review | Done | Task completed and verified | User |

## Requirements

1. Detect when `{cursor.log_path}/globalStorage/state.vscdb` database file is modified
2. Query database to identify which composer IDs were updated
3. Parse updated conversation content from database
4. Identify new messages added to existing conversation (compare `fullConversationHeadersOnly` array length)
5. Update database records with new messages
6. Preserve existing messages while adding new ones
7. Handle cases where conversation structure changes
8. Track which composer IDs and message counts have been processed to avoid duplicates (store in database)
9. Handle concurrent updates gracefully
10. Update session metadata when conversations are updated

## Implementation Plan

1. Extend watcher service (from task 2-3):
   - Track which composer IDs have been processed
   - Detect modification events for `state.vscdb` database file
   - Query database to identify which composer IDs were updated
2. Implement update detection:
   - Location: `internal/cursor/updater.go`
   - Package: `cursor`
3. Track processed conversations:
   - Maintain state of processed composer IDs (composer ID + message count)
   - Store state in database (add `processed_conversations` table or use existing schema)
   - Load state on startup from database
4. Implement incremental parsing:
   - Use parser from task 2-4 with incremental support
   - Query database for updated composer data
   - Compare `fullConversationHeadersOnly` array length to detect new messages
   - Only parse new messages since last update
   - Merge new messages with existing conversation
5. Implement database update logic:
   - Query existing conversation from database
   - Insert new messages into database linked to conversation
   - Update conversation metadata (message count, last message time)
   - Update session metadata (message count, end time, duration)
6. Handle database updates:
   ```go
   type ConversationUpdater interface {
       ProcessUpdate(composerID string) error
       HasBeenProcessed(composerID string, messageCount int) bool
       MarkAsProcessed(composerID string, messageCount int) error
       DetectUpdatedComposers() ([]string, error) // Query database for updated composer IDs
   }
   ```
7. Implement atomic database updates:
   - Use database transactions for atomic operations
   - Insert new messages and update metadata in single transaction
   - Rollback on error to maintain consistency
   - Handle errors gracefully
8. Handle edge cases:
   - Conversation not found in database
   - Database corruption or connection issues
   - Concurrent modifications (use database locking)
   - Large conversation updates
   - Missing or corrupted composer data
9. Write unit tests for update handling

## Test Plan

**Objective**: Verify conversation updates are detected and database records are updated correctly.

**Test Scope**:
- Update detection
- Incremental parsing
- Database record updates
- State tracking in database
- Concurrent updates
- Transaction handling

**Environment & Setup**:
- Use test SQLite database for testing
- Simulate database modifications
- Test with sample conversations

**Key Test Scenarios**:
1. Detect modification to Cursor database file
2. Query database to identify updated composer IDs
3. Compare message counts to detect new messages
4. Parse only new messages from update
5. Insert new messages into database correctly
6. Update conversation metadata correctly (message count, timestamps)
7. Update session metadata correctly (message count, end time, duration)
8. Track processed composer IDs correctly in database
9. Handle composer ID that was already processed (same message count)
10. Handle concurrent updates gracefully (database locking)
11. Handle database transactions correctly (rollback on error)
12. Handle missing conversations gracefully
13. Handle corrupted database entries gracefully

**Success Criteria**:
- Updates detected correctly
- New messages inserted correctly
- Existing messages preserved
- State tracking in database works correctly
- Atomic database updates work correctly
- Session metadata updated correctly

## Verification

- [x] Update detection implemented
- [x] Processed conversation tracking in database implemented
- [x] Incremental parsing works
- [x] Database update logic implemented
- [x] New messages inserted correctly
- [x] Conversation metadata updated correctly
- [x] Session metadata updated correctly
- [x] Atomic database updates implemented
- [x] Edge cases handled
- [x] Unit tests written and passing
- [x] State persistence in database works

## Files Modified

- `internal/db/migrations/000004_create_processed_conversations_table.up.sql` (new) - Database migration for processed conversations tracking
- `internal/db/migrations/000004_create_processed_conversations_table.down.sql` (new) - Migration rollback
- `internal/cursor/cursor_db.go` (new) - Shared helper function for opening Cursor database
- `internal/cursor/updater.go` (new) - Conversation update handling
- `internal/cursor/updater_test.go` (new) - Unit tests for updater
- `internal/cursor/parser.go` (updated) - Refactored to use shared OpenCursorDatabase helper
- `docs/api-specs/cursor/cursor-api.md` (updated) - API specification with ConversationUpdater interface and OpenCursorDatabase helper

