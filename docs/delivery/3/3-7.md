# 3-7 Implement database persistence for commits

[Back to task list](./tasks.md)

## Description

Implement functionality to persist git commits and their diffs to the database, following the same pattern as conversation storage. Commits are stored with their metadata, full diffs, file-level changes, and session correlation information.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-11-16 00:55:17 | Created | N/A | Proposed | Task file created | System |
| 2025-01-XX XX:XX:XX | Status Update | Proposed | Proposed | Changed from markdown export to database persistence | System |
| 2025-01-XX XX:XX:XX | Status Update | Proposed | Done | Implementation complete | System |

## Requirements

1. Store commits in database with all metadata
2. Store file-level changes in separate table with foreign key relationship
3. Handle large diffs efficiently (truncated diffs stored with flag)
4. Support session correlation (foreign key to sessions table)
5. Handle duplicate commits gracefully (ON CONFLICT)
6. Store parent commit hashes as JSON array
7. Verify session exists before storing (if sessionID provided)
8. Use transactions to ensure atomicity of commit + file changes
9. Follow same storage pattern as conversation storage
10. Support querying commits by session, repository, or hash

## Implementation Plan

1. Create database migrations:
   - `000006_create_commits_table.up.sql` - Main commits table
   - `000006_create_commits_table.down.sql` - Rollback
   - `000007_create_commit_files_table.up.sql` - File-level changes table
   - `000007_create_commit_files_table.down.sql` - Rollback
2. Create commit storage service:
   - Location: `internal/git/storage.go`
   - Package: `git`
3. Define storage interface:
   ```go
   type CommitStorage interface {
       StoreCommit(commit *Commit, diff *CommitDiff, correlation *CommitSessionCorrelation, repository *Repository, sessionID string) error
       GetCommit(commitHash string) (*StoredCommit, error)
       GetCommitsBySession(sessionID string) ([]*StoredCommit, error)
       GetCommitsByRepository(repoPath string) ([]*StoredCommit, error)
   }
   ```
4. Implement storage following conversation storage pattern:
   - Verify session exists if sessionID provided
   - Begin transaction
   - Store commit in `commits` table (use commit hash as primary key)
   - Store all file changes in `commit_files` table within same transaction
   - Handle ON CONFLICT for duplicate commits
   - Commit transaction
5. Handle data types:
   - Store parent hashes as JSON array in TEXT field
   - Convert boolean flags to integers (is_merge, diff_truncated)
   - Handle nullable fields (session_id, correlation_type, diff_truncated_at)
   - Store full diff as TEXT (may be NULL for very large commits)
6. Implement retrieval methods:
   - GetCommit: Retrieve commit by hash with all file changes
   - GetCommitsBySession: Retrieve all commits for a session
   - GetCommitsByRepository: Retrieve all commits for a repository
   - Parse JSON fields (parent_hashes) on retrieval
7. Integration:
   - Use commit from poller (task 3-3)
   - Use diff from task 3-5
   - Use correlation from task 3-6
   - Use repository from discovery (task 3-2)
8. Write unit tests with test database

## Test Plan

**Objective**: Verify database persistence correctly stores and retrieves commits with all metadata and file changes.

**Test Scope**:
- Database schema and migrations
- Commit storage with all fields
- File change storage
- Transaction handling
- Duplicate commit handling
- Session verification
- Retrieval methods
- JSON field parsing

**Environment & Setup**:
- Use test database for testing
- Create test commits with various characteristics
- Test with and without session correlation
- Test with large diffs and truncated diffs

**Key Test Scenarios**:
1. Store commit with all metadata and file changes
2. Store commit without session correlation
3. Store commit with truncated diff
4. Store commit with merge commit flag
5. Handle duplicate commit (ON CONFLICT)
6. Verify session exists before storing
7. Retrieve commit by hash with all file changes
8. Retrieve commits by session
9. Retrieve commits by repository
10. Handle commits with no file changes
11. Handle commits with multiple file changes
12. Parse parent hashes JSON correctly
13. Handle nullable fields correctly
14. Transaction rollback on error

**Success Criteria**:
- Commits stored correctly in database
- File changes stored correctly with foreign key
- Large diffs handled efficiently
- Duplicate commits handled gracefully
- Session verification works
- Retrieval methods work correctly
- JSON fields parsed correctly
- Transactions ensure atomicity
- Error handling works correctly

## Verification

- [ ] Database migrations created and tested
- [ ] Commit storage service implemented
- [ ] Storage interface matches specification
- [ ] Commits stored correctly with all fields
- [ ] File changes stored correctly
- [ ] Transaction handling works
- [ ] Duplicate commit handling works
- [ ] Session verification works
- [ ] Retrieval methods implemented
- [ ] JSON field parsing works
- [ ] Unit tests written and passing

## Files Modified

- `internal/db/migrations/000006_create_commits_table.up.sql` (new) - Commits table migration
- `internal/db/migrations/000006_create_commits_table.down.sql` (new) - Commits table rollback
- `internal/db/migrations/000007_create_commit_files_table.up.sql` (new) - Commit files table migration
- `internal/db/migrations/000007_create_commit_files_table.down.sql` (new) - Commit files table rollback
- `internal/git/storage.go` (new) - Commit storage service
- `internal/git/storage_test.go` (new) - Unit tests for storage
- `internal/git/types.go` (updated) - Add CommitDiff, FileDiff, CommitSessionCorrelation types
- `docs/api-specs/git/git-api.md` (updated) - API specification
